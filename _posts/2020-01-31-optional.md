---
comments: true
title: [Swift ) 옵셔널(Optional)]
key: 202001311
modify_date: 2020-07-03
picture_frame: shadow
tags:
  - [swift]
  - [interview]
---
    
    
```
var num: Int
num = nil // error!
```
이 코드가 정상적으로 작동할까?
 
`'nil' cannot be assigned to type 'Int'` 에러가 발생한다.
에러내용을 보면 Int 타입에 nil이 올 수 없는다는 내용인데,   
> **nil**은 값이 없다는 것을 표현한다.
 
```
var num: Int?
num = nil
```
Int에 **물음표(?)** 를 붙여주니 잘 작동한다.   
**옵셔널 기호** 를 붙여주면 이 변수에 값이 있을 수도 없을 수도 있기 때문에 nil을 할당해도 에러가 나지 않는 것이다.
그렇다면 옵셔널이란 뭘까?
 
## 옵셔널이란?
 
옵셔널(Optional)은 스위프트의 특징 중 하나인 **안정성**을 기반으로 하는 문법으로, 값이 있을 수도 없을 수도 있는 것을 나타낸다.   
그리고 옵셔널은 처음 선언, 즉 초기화할 때 값을 할당해주지 않아도 된다. 옵셔널이기 때문이다.   
물론 값을 할당해주지 않는다면 값은 자동적으로 nil이다.
 
옵셔널을 박스에 포장되어 있는 값이라고 생각해보자.   
그렇다면 우리가 그동안 선언한 변수는 박스에 포장되어 있지 않은 것이다.
 
### 옵셔널 기본 형태
 
옵셔널 변수나 상수는 데이터 타입 뒤에 물음표(?)를 붙여 표현해준다.
```
var num: Int? = 5
```
이제 이러한 코드를 보면 유추할 수 있다.   
**num이라는 변수에는 Int값이 올 수도 있고, nil이 올 수도 있다.**
```
var num: Int? = 5
var new = num
```
만약 옵셔널인 num을 new라는 새로운 변수에 할당해준다면 new는...?
옵셔널로 선언되는 순간 **new**라는 변수도 마찬가지로 옵셔널이 된다.
 
## 옵셔널 추출
 
옵셔널이 아닌 변수에는 옵셔널 값을 할당할 수 없으므로 값을 추출해서 할당해줘야 한다.   
 
쉽게 말해,
```
var num: Int? = 5
var new: Int
 
new = num // error!
```
위의 예를 보면 new는 옵셔널이 아니기 때문에 옵셔널인 num을 할당할 수 없다는 것이다.   
 
옵셔널 추출 방법에는 **강제 추출, 옵셔널 바인딩, 암시적 추출 옵셔널** 이렇게 3가지가 있다.
 
### 강제 추출
 
**강제 추출**은 옵셔널에 값이 있든 없든 깨부시고 확인하는 방법으로, 깨부셨을 때 값이 있으면 있는 것이고 없으면 런타임에러가 발생한다. 
```
var num: Int? = 5
var new = num!
```
이렇게 옵셔널 값 뒤에 느낌표(!)를 붙여주면 옵셔널을 강제 추출하는 것이다.   
옵셔널인 num을 깨부시고 실제 값을 할당한 것이니, **new는 Int타입**이다.
```
var num: Int? = nil
var new: Int = num! // error!
```
num은 옵셔널이기 때문에 nil을 할당할 수 있다. 그러나, new는 Int 타입이기 때문에
```
Unexpectedly found nil while unwrapping an Optional value
```
이런 에러가 발생한다.
    
    
```
var num: Int? = nil
var new = num! // error!
```
이 역시도 같은 에러가 발생한다. num이 nil을 반환했기 때문이다.   
**즉!! 강제 추출은 조심해서 사용하자.**   
**옵셔널 바인딩이나 체이닝으로 매번 값을 추출하기 귀찮거나, 로직상 절대 nil이 할당되지 않을 것 같을 때에만 사용하자.**     
 
### 옴셔널 바인딩
 
**옵셔널 바인딩**은 옵셔널에 값이 있는지, 없는지 **먼저 확인해주는 작업**을 말한다.   
확인한 후 값이 있을 때와 없을 때에 다르게 코드를 실행시킬 수 있다.
```
if let 값이 있다면 값을 할당할 상수 = 옵셔널 {
    // 값이 있을 때 실행할 코드
} else {
    // 값이 없을 때(nil일 때) 실행할 코드
}
```
기본코드는 이렇게 구성되어 있는데 `if let`도 결국 if 기반 구문이기 때문에 `else`구문을 생략할 수 있다.
```
if let 값이 있다면 값을 할당할 상수 = 옵셔널 {
    // 값이 있을 때 실행할 코드
}
```
만약 이렇게 `if let`으로만 구성되어 있다면 값이 없을 때 실행될 코드는 없는 것이다.
물론 `if var`라고 사용할 수 있지만 옵셔널 바인딩을 할 때는 거의 해당 값에 값을 주려는 것보다 값을 사용하는 경우가 많기 때문에 `if let`을 훨씬 많이 본 것이다.   
```
if let 값이 있다면 값을 할당할 상수1 = 옵셔널1, 값이 있다면 값을 할당할 상수2 = 옵셔널2 {
    // 두 변수 모두 값이 있을 때 실행할 코드
}
```
그리고 말했듯이 if 기반 구문이기 때문에 &&를 할용할 수 있다.   
*(&& 대신 , 쓸 수 있는 건 다 알겠죠..?)*
    
    
if-let 말고 **guard문**으로도 옵셔널 바인딩을 할 수 있다.
```
guard let 값이 있다면 값을 할당할 상수 = 옵셔널 변수 else { 
    // 값이 없을 때 실행할 코드
}
```
if-let과 다른 점이 있는데, if-let은 값이 있을 때 실행할 코드와 없을 때 실행할 코드를 나눌 수 있지만 guard는 값이 없을 때 실행할 코드만 작성한다.   
또한 아주 결정적인 차이점으로, if-let으로 바인딩했을 때 값을 할당한 상수는 if문 내에서만 사용할 수 있고 guard로 바인딩했을 때 값을 할당한 상수는 이후에도 쭉 사용가능하다.
 
- if let으로 옵셔널 바인딩했을 때
```
var value: String? = "optional"
 
if let newValue = value {
    print(newValue) // "optional"
} else {
    // newValue 사용 못함
}
// newValue 사용 못함
```
 
- guard로 옵셔널 바인딩했을 때
```
var value: String? = "optional"
 
guard let newValue = value else {
    // newValue 사용 못함
}
print(newValue) // "optional"
```
 
### 암시적 추출 옵셔널
 
**암시적 추출 옵셔널**은 해당 데이터 타입 뒤에 물음표 대신 느낌표(!)를 붙여주며,
암시적 추출 옵셔널로 선언된 타입은 실제 값처럼 사용할 수 있으나 옵셔널이기 때문에 nil을 할당할 수 있다.
```
var num: Int!
num = 5
 
if let num = num {
    print(num)
} else {
    print("num is nil")
}
// 5
```
옵셔널 바인딩을 통해 안전하게 값을 추출해야 "5"라는 깔끔한 실제 값을 반환할 수 있고,
```
var num: Int!
num = 5
print(num) // Optional(5)
```
만약 이렇게 바로 추출한다면 옵셔널 값으로 반환된다.
 
이럴땐 이렇게 `Int`타입이라고 명시를 해주고 "암시적 추출 옵셔널"을 할당해주면 자동으로 언래핑이 되어 값이 추출된다.
```
var new: Int = num
print(new) // 5
```
만약 이 상황에서 num을 암시적 추출 옴셔널이 아닌 `Int?`타입으로 바꾼다면 바로 컴파일 에러가 발생한다.   
그렇게 되면 "??"나 "!"를 통해 언래핑을 해야 값을 사용할 수 있다.(옵셔널 바인딩도 가능!)
    
    
물론 이렇게 nil을 할당할 수도 있다.
```
num = nil

if let num = num {
    print(num)
} else {
    print("num is nil")
}
// "num is nil"
```
그러나 암시적 추출 옵셔널은 값을 **자동 추출**하거나 **강제 추출**하기 때문에 실제로 값이 있는지 확인할 수 없어 nil이 저장된 상태에서 값을 추출하면 강제 추출처럼 컴파일 에러가 발생한다.

프로젝트를 하다보면 암시적 추출 옵셔널만을 사용해야 하는 경우도 있는데 바로 **@IBOutlet**과 **API에서 암시적 추출 옵셔널을 반환할 때**이다.
때문에 @IBOutlet이 정상적으로 연결되지 않아 nil을 반환할 경우, 해당 UI가 속한 뷰가 나타나기도 전에 바로 런타임 에러가 발생한다.
 
## 옵셔널 체이닝
 
옵셔널 체이닝은 하위 프로퍼티에 옵셔널 값이 있는지 마침표(.)을 통해 **연속적**으로 체이닝하여 확인할 수 있는 방법이다.   
**중간에 nil 값이 하나라도 발견된다면 전체 반환값이 nil로 반환된다.**
```
class SomeClass {
    var some = "some"
}
 
class OtherClass {
    var other: SomeClass?
}
 
let value = OtherClass()
print(value.other?.some) // nil
```
바로 `value.other?.some` 이 부분을 옵셔널 체이닝이라고 한다.   
other라는 변수가 초기화(선언)할 때 SomeClass를 옵셔널 값으로 상속하고 있어 중간에 other가 값이 없는 것이고, 고로 `value.other?.some` 값이 nil을 반환한 것이다.   
또한 애초에 마지막 코드라인을 작성할 때 **other가 옵셔널이니 wrapping을 하라는 warning**이 뜬다.
```
let value = OtherClass()
let optional = value.other?.some
```
other가 옵셔널 값이고 옵셔널 체이닝의 전체 반환값이 nil이기 때문에 ptional이라는 변수 역시 String? 타입으로 초기화(선언)된다.
```
class OtherClass {
    var other = SomeClass()
}

let value = OtherClass()
print(value.other.some) // some
```
만약 옵셔널이 아닌 SomeClass 자체로 other를 초기화한다면 other가 nil이 아니기 때문에 잘 작동한다.
 
*사실 나는 실제 프로젝트에서 옵셔널을 확인할 때 옵셔널 바인딩을 많이 사용하기도 하지만, print를 통해 출력해보고 "어? 없네"하고 코드를 수정하거나 옵셔널 바인딩을 하곤 한다.*
    
 
#### 마무리로, 옵셔널은 스위프트의 특징 중에서 안정성(Safe)를 보장하기 위한 문법이고, 옵셔널이 존재함으로써 옵셔널이 아닌 타입은 무조건 데이터가 존재할 것이라고 보장할 수 있다.
    
    
#### Optional이란 무엇이지 설명하시오.
 
- 옵셔널이란 값이 있을 수도, 없을 수도 있는 것을 의미하고 nil 값을 할당할 수 있습니다. 옵셔널의 값을 추출하는 방법에는 강제 추출, 옵셔널 바인딩, 암시적 추출 옵셔널이 있는데, 강제 추출은 느낌표(!)를 통해 옵셔널의 실제 값을 추출하는 방법으로 만약 값이 없다면 런타임 에러가 발생하고 때문에 값이 있다는 확신이 없다면 사용하는 것을 지양합니다. 그리고 옵셔널 바인딩은 if-let이나 guard문을 통해 옵셔널에 값이 있는지 확인하고 사용하는 방법으로 if-let으로 추출한 값이 할당된 상수는 해당 scope 내에서만 사용할 수 있으나, guard문으로 추출한 값이 할당된 상수는 해당 scope 외에서 사용할 수 있다. 마지막으로 암시적 추출 옵셔널은 물음표 대신 느낌표를 붙여 값의 자동 추출과 강제 추출을 유용하게 사용할 수 있다. 암시적 추출 옵셔널은 @IBOutlet을 선언할 때 사용된다.
 
#### Optional은 Swift에서 어떻게 구현되어 있는지 설명하시오.

#### Optional이 왜 필요한지 설명하시오.
 
- 옵셔널은 그저 nil의 가능성을 명시하기 위해 필요하고, 스위프트의 특징인 안전을 기반으로 한 개념인만큼 값을 안전하게 사용하기 위해 필요합니다. 또한 메모리 관리를 위해서도 꼭 필요한 개념입니다. 옵셔널이 아닌 타입으로 선언하거나 값을 할당하면 메모리를 사용하다가 값이 없어져도 
  
#### Reference)
 
[https://zeddios.tistory.com/16](https://zeddios.tistory.com/16)
