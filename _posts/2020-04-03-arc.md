---
comments: true
title: [Swift ) ARC(Automatic Reference Counting)]
key: 202004031
modify_date: 2021-01-15
picture_frame: shadow
tags:
  - [swift]
---
 
## ARC란?
 
**ARC**란 Automatic Reference Counting의 약자로, 자동참조카운팅을 통해 앱의 메모리 사용을 추적하고 관리하는 기능이다.   
자동참조카운팅은 인스턴스가 몇 번 참조되는지 카운팅하는 것이며 **인스턴스를 참조한다는 것**은 `var example = Intance()`에서 `Instance()` 이렇게 변수 example에 의해 참조되는 것을 말한다.   
그리고 ARC는 이 참조를 추적해 인스턴스 참조가 몇 번 일어나는지 세어주며 참조의 수가 0이 되면 해당 인스턴스는 **메모리에서 해제**된다.
바로 `example = nil` 이런식으로 메모리에서 해제되어 Instance를 램에서 제거하는 것이다.   
    
    
자동참조카운팅은 **오직 클래스의 인스턴스에만 적용**된다.   
말 그대로 ARC는 인스턴스의 **"참조"** 를 추적하는 것이고, 구조체이나 열거형과 달리 클래스는 복사가 아니라 **참조**를 통해 인스턴스에 접근이 가능하기 때문이다.
 
## ARC 동작 방법
 
ARC는 클래스에 새 인스턴스가 정의될 때마다 해당 인스턴스에 대한 정보를 저장하기 위해 메모리를 할당한다.
그리고 메모리에는 인스턴스의 타입 정보와 인스턴스의 값을 저장한다.   
더이상 인스턴스가 필요하지 않으면 자동으로 메모리에서 비우는 방식으로 메모리를 관리한다.   
그러나!! 인스턴스를 해제하면 해당 인스턴스의 프로퍼티나 메소드에 접근할 수 없고, 이 때 접근하려하면 앱에서 충돌이 발생한다.   
따라서 인스턴스를 필요로 하는 동안에는 메모리에서 해제되지 않게 하기 위해 **인스턴스 할당할 때 강한 참조(Strong Reference)를 연결하고 ARC가 인스턴스의 참조를 추적**하는 것이다.
```
class Person {
    let name: String
    
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    
    deinit {
        print("\(name) is being deinitialized")
    }
}
```
이렇게 Person이라는 클래스가 정의되고 클래스에 인스턴스가 정의되면서 ARC가 Person 인스턴스를 추적하고 관리한다.
```
var reference1: Person?
var reference2: Person?
var reference3: Person?
```
그리고 Person 클래스를 세 변수에 정의했다. 이 때까지는 아직 참조카운팅이 발생하지 않는다.   
Person 클래스가 옵셔널로 호출되어 아직 참조는 발생하지 않았기 때문이다.
```
reference1 = Person(name: "John Appleseed") // "John Appleseed is being initialized"
```
이제 Person 클래스가 reference1이라는 변수에 초기화되었고 동시에 강한 참조로 연결되었다.
강한 참조로 연결되었기 때문에 Person 클래스에 정의된 init이 호출되었고, ARC는 Person 클래스가 메모리에서 해제되지 않고 유지되도록 한다.   
그리고 ARC 참조 카운트가 +1이 되었다.
```
reference2 = reference1
reference3 = reference1
```
나머지 두 개의 변수에도 동일한 Person 인스턴스가 할당되었다.   
이렇게 되면 하나의 Person 클래스 인스턴스에 총 3개의 강한 참조가 연결된 것이다.
```
reference1 = nil
reference2 = nil
```
이 때 두 개의 변수에 nil을 할당해주면, Person 클래스 인스턴스에는 하나의 강한 참조가 남게 된다.   
아직 하나의 강한 참조가 남았기 때문에 메모리에서 해제되지 않는다.
```
reference3 = nil // "John Appleseed is being deinitialized"
```
마지막으로 하나 남은 강한 참조까지 끊어지면 ARC 참조 카운트가 0이 되어 Person 클래스 인스턴스가 메모리에서 해제된다.   
그리고 Person 클래스의 참조가 모두 없어져 Person 클래스에 정의된 deinit이 호출된다.

## 강한 순환 참조(Strong Reference Cycle)
 
### 강한 순환 참조의 문제점
 
앞서 예제들을 통해 참조가 되어 참조 카운트가 1이 증가하면 그것이 강한 참조라는 것을 알 수 있었다.   
그리고 ARC는 클래스의 인스턴스 참조 수가 무조건 0이 되어야만 메모리에서 해제하고, 0이 아니면 메모리에서 해제하지 않기 때문에 메모리 낭비가 일어날 수 있다는 것도 알게 되었다.   
 
그렇다면 이제 ARC의 문제는, **두 개의 클래스 인스턴스가 서로를 참조하는 경우엔 강한 참조 순환이 발생**할 수 있다는 것이다.   
서로가 강한 참조로 연결되어 있으면 참조 카운트가 0이 될 수 없고, **영원히 메모리에서 해제되지 않는다.** 즉, **메모리 누수**가 발생한다.
```
class Person {
    let name: String
    
    init(name: String) { self.name = name }
    
    var apartment: Apartment?
    
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    
    init(unit: String) { self.unit = unit }
    
    var tenant: Person?
    
    deinit { print("Apartment \(unit) is being deinitialized") }
}
```
Person 클래스의 apartment라는 변수는 Apartemnt? 타입이고, Apartment 클래스의 tenant라는 변수는 Person? 타입이다.   
```
var john: Person?
var unit4A: Apartment?
```
그리고 여기 john이라는 변수는 Person?, unit4A라는 변수는 Apartment? 타입이다.   
아직 옵셔널타입이기 때문에 초기값이 nil이고, 참조는 발생하지 않았다.
```
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
```
이제 john이 Person 클래스를 초기화하면서 john은 Persone 클래스 인스턴스와 강한 참조로 연결되고,   
unit4A도 Apertment 클래스를 초기화하면서 unit4A는 Apartment 클래스 인스턴스와 강한 참조로 연결되었다.   
<p style="text-align:center"><img width="530" alt="KakaoTalk_Photo_2021-01-24-18-39-42" src="https://user-images.githubusercontent.com/50580583/105626837-f1739300-5e75-11eb-8857-740009bc0bd5.png"></p>
그럼 이제 Person과 Apartment의 참조 카운팅은 각각 1이 된 것이다.
```
john!.apartment = unit4A
unit4A!.tenant = john
```
그리고 john의 apartment에 unit4A를 할당해 john의 apartment와 unit4A가 강한 참조로 연결되고,   
unit4A의 tenant에 john을 할당해 unit4A의 tenant와 john이 강한 참조로 연결되었다.   
그럼 Person과 Apartment의 참조 카운팅은 각각 2가 된 것이다.
<p style="text-align:center"><img width="525" alt="KakaoTalk_Photo_2021-01-24-18-40-03" src="https://user-images.githubusercontent.com/50580583/105626883-5d55fb80-5e76-11eb-9c19-5101cb522fc7.png"></p>
또한 사진을 보면 알 수 있듯이 john과 unit4A가 **강한 순환 참조**로 연결되었다.
```
john = nil
unit4A = nil
```
메모리에서 해제하기 위해 nil을 할당해줬다.   
그러나 nil을 할당해도 Person과 Apartment의 참조 카운팅이 각각 2이고, 각각의 변수에 nil을 할당하는 것은 강한 순환 참조가 끊는 것이 아니기 때문에 메모리에서 해제되지 않는다.   
그리고 john과 unit4A에 nil을 할당해버려서 강한 참조 순환을 제거하기 위해 접근하는 것도 불가능하고 계속 메모리만 먹게 되는 것이다.
```
john?.apartment = nil
unit4A?.tenant = nil
```
물론 john과 unit4A 자체에 nil을 할당하기 전에 각 인스턴스에 nil을 할당해 강한 순환 참조를 제거할 수도 있다.   
그러나 이 문제를 가장 확실하게 해결하기 위해서 우리는 참조해도 참조 카운트가 증가하지 않는 방법을 사용해야 한다.

### 약한 참조(Weak Reference)
 
강한 순환 참조와 약한 참조에 대해서는 [프로토콜](https://khyeji98.github.io/post/2020/03/01/protocol.html#anyobject-class) 포스팅에서 class-only 프로토콜에 대해 설명하면서 매우 가볍게 언급한 적이 있었는데, 이번에는 더 자세히 알아보자.
    
    
여기
 
### 미소유 참조(Unowned Reference)
 
여기
 
### 클로저에서의 강한 순환 참조
 
지금까지는 클래스에서의 강한 순환 참조와 해결 방법인 weak, unowned에 대해 알아봤는데, 이번엔 클로저 내부에서 발생한 강한 순환 참조 문제와 weak, unowned를 사용한 해결법을 알아보자.
    
    
여기
 
#### Reference)
 
[https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)   
[https://shinhyogeun.tistory.com/2](https://shinhyogeun.tistory.com/2)
