---
comments: true
title: [Swift ) ARC(Automatic Reference Counting)]
key: 202004031
modify_date: 2021-01-15
picture_frame: shadow
tags:
  - [swift]
---
 
## ARC란?
 
**ARC**란 Automatic Reference Counting의 약자로, 자동참조카운팅을 통해 앱의 메모리 사용을 추적하고 관리하는 기능이다.   
자동참조카운팅은 인스턴스가 몇 번 참조되는지 카운팅하는 것이며 **인스턴스를 참조한다는 것**은 `var example = Intance()`에서 `Instance()` 이렇게 변수 example에 의해 참조되는 것을 말한다.   
그리고 ARC는 이 참조를 추적해 인스턴스 참조가 몇 번 일어나는지 세어주며 참조의 수가 0이 되면 해당 인스턴스는 **메모리에서 해제**된다.
바로 `example = nil` 이런식으로 메모리에서 해제되어 Instance를 램에서 제거하는 것이다.   
    
    
자동참조카운팅은 **오직 클래스의 인스턴스에만 적용**된다.   
말 그대로 ARC는 인스턴스의 **"참조"** 를 추적하는 것이고, 구조체이나 열거형과 달리 클래스는 복사가 아니라 **참조**를 통해 인스턴스에 접근이 가능하기 때문이다.
 
## ARC 동작 방법
 
ARC는 클래스에 새 인스턴스가 정의될 때마다 해당 인스턴스에 대한 정보를 저장하기 위해 메모리를 할당한다.
그리고 메모리에는 인스턴스의 타입 정보와 인스턴스의 값을 저장한다.   
더이상 인스턴스가 필요하지 않으면 자동으로 메모리에서 비우는 방식으로 메모리를 관리한다.   
그러나!! 인스턴스를 해제하면 해당 인스턴스의 프로퍼티나 메소드에 접근할 수 없고, 이 때 접근하려하면 앱에서 충돌이 발생한다.   
따라서 인스턴스를 필요로 하는 동안에는 메모리에서 해제되지 않게 하기 위해 **인스턴스 할당할 때 강한 참조(Strong Reference)를 연결하고 ARC가 인스턴스의 참조를 추적**하는 것이다.
```
class Person {
    let name: String
    
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    
    deinit {
        print("\(name) is being deinitialized")
    }
}
```
이렇게 Person이라는 클래스가 정의되고 클래스에 인스턴스가 정의되면서 ARC가 Person 인스턴스를 추적하고 관리한다.
```
var reference1: Person?
var reference2: Person?
var reference3: Person?
```
그리고 Person 클래스를 세 변수에 정의했다. 이 때까지는 아직 참조카운팅이 발생하지 않는다.   
Person 클래스가 옵셔널로 호출되어 아직 참조는 발생하지 않았기 때문이다.
```
reference1 = Person(name: "John Appleseed") // "John Appleseed is being initialized"
```
이제 Person 클래스가 reference1이라는 변수에 초기화되었고 동시에 강한 참조로 연결되었다.
강한 참조로 연결되었기 때문에 Person 클래스에 정의된 init이 호출되었고, ARC는 Person 클래스가 메모리에서 해제되지 않고 유지되도록 한다.   
그리고 ARC 참조 카운트가 +1이 되었다.
```
reference2 = reference1
reference3 = reference1
```
나머지 두 개의 변수에도 동일한 Person 인스턴스가 할당되었다.   
이렇게 되면 하나의 Person 클래스 인스턴스에 총 3개의 강한 참조가 연결된 것이다.
```
reference1 = nil
reference2 = nil
```
이 때 두 개의 변수에 nil을 할당해주면, Person 클래스 인스턴스에는 하나의 강한 참조가 남게 된다.   
아직 하나의 강한 참조가 남았기 때문에 메모리에서 해제되지 않는다.
```
reference3 = nil // "John Appleseed is being deinitialized"
```
마지막으로 하나 남은 강한 참조까지 끊어지면 ARC 참조 카운트가 0이 되어 Person 클래스 인스턴스가 메모리에서 해제된다.   
그리고 Person 클래스의 참조가 모두 없어져 Person 클래스에 정의된 deinit이 호출된다.

## 강한 참조 순환(Strong Reference Cycle)
 
앞서 예제들을 통해 참조가 되어 참조 카운트가 1이 증가하면 그것이 강한 참조라는 것을 알 수 있었다.   
그리고 ARC는 클래스의 인스턴스 참조 수가 무조건 0이 되어야만 메모리에서 해제하고, 0이 아니면 메모리에서 해제하지 않기 때문에 메모리 낭비가 일어날 수 있다는 것도 알게 되었다.   
 
그렇다면 이제 ARC의 문제는, **두 개의 클래스 인스턴스가 서로를 참조하는 경우엔 강한 참조 순환이 발생**할 수 있다는 것이다.   
서로가 강한 참조로 연결되어 있으면 참조 카운트가 0이 될 수 없고, **영원히 메모리에서 해제되지 않는다.** 즉, **메모리 누수**가 발생한다.
```
class Person {
    let name: String
    
    init(name: String) { self.name = name }
    
    var apartment: Apartment?
    
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    
    init(unit: String) { self.unit = unit }
    
    var tenant: Person?
    
    deinit { print("Apartment \(unit) is being deinitialized") }
}
```
Person 클래스의 apartment라는 변수는 Apartemnt? 타입이고, Apartment 클래스의 tenant라는 변수는 Person? 타입이다.   
```
var john: Person?
var unit4A: Apartment?
```
그리고 여기 john이라는 변수는 Person?, unit4A라는 변수는 Apartment? 타입이다.   
아직 옵셔널타입이기 
```
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
```
 
#### Reference)
 
[https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)   
[https://shinhyogeun.tistory.com/2](https://shinhyogeun.tistory.com/2)
