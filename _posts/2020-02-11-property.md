---
comments: true
title: [Swift ) 프로퍼티(Property)]
key: 202002111
modify_date: 2020-05-01
picture_frame: shadow
tags:
  - [swift]
---
 
# 프로퍼티(Property)
 
### 프로퍼티란?
 
프로퍼티란 클래스, 구조체, 열거형과 관련된 값으로 프로퍼티에는 총 5가지 종류가 있다.   
 
- 저장 프로퍼티
- 저장 지연 프로퍼티
- 연산 프로퍼티
- 프로퍼티 옵저버(감시자)
- 타입 프로퍼티
 
인스턴스 프로퍼티에도 저장 프로퍼티와 연산 프로퍼티가 있고, 타입 프로퍼티에도 저장 프로퍼티와 연산 프로퍼티가 있다.   
    
    
저장 프로퍼티와 연산 프로퍼티에 대해 알아보기 전에 인스턴스 프로퍼티와 타입 프로퍼티에 대해 간단히 알아보자.
**인스턴스 프로퍼티**란 특정 타입의 인스턴스에 속하는 프로퍼티이고,   
**타입 프로퍼티**란 
 
### 저장 프로퍼티(Stored Property)
 
저장 프로퍼티는 단순히 값을 저장하고 있는 프로퍼티로, 타입 내부에 변수(var)나 상수(let)로 선언할 수 있다.   
    
    
먼저 구조체에서의 저장 프로퍼티에 대해 알아보자.
```
struct SomeStruct {
    let some: Int
    var other: Int
}
 
var value = SomeStruct(some: 0, other: 0)
value.other = 2
value.some = 2 // error! : 'some' is 'let'
```
구조체를 초기화할 때 저장 프로퍼티에 **초기값**을 줄 수 있으나, 저장 프로퍼티가 상수라면 해당 저장 프로퍼티는 **초기값**만 할당받을 수 있다.
```
struct SomeStruct {
    let some: Int = 0
    var other: Int
}

var value = SomeStruct(other: 0)
```
만약 정의할 때 **기본값**을 할당받는다면 구조체를 초기화할 때 기본값이 있는 저장 프로퍼티는 초기화하지 않아도 된다.   
역시, **기본값**을 할당받은 저장 프로퍼티가 상수라면 해당 저장 프로퍼티는 **기본값**만 할당받을 수 있다.
 
#### 구조체를 상수로 선언할 때 저장 프로퍼티의 불변성
 
```
let value = SomeStruct(some: 0, other: 0)
value.other = 2
```
애초에 구조체 초기화를 상수로 한다면 구조체가 초기화된 상수 자체가 값을 변경할 수 없다.   
그러나 클래스는 참조 타입이기 때문에 상수로 초기화되어도 값을 변경할 수 있다.
    
    
```
class SomeClass {
    let some: Int = 0
    var other: Int = 0
}
 
var value = SomeClass()
value.other = 1
value.some = 1 // error! : 'some' is 'let'
```
클래스에서의 저장 프로퍼티에 대해 알아보면, 클래스는 저장 프로퍼티에 반드시 **기본값**을 할당해줘야 하며 역시 저장 프로퍼티가 상수라면 초기화 이후 값을 할당할 수 없다.
 
### 저장 지연 프로퍼티(Lazy Stored Property)
 
저장 지연 프로퍼티는 클래스의 프로퍼티로, 다른 클래스나 구조체의 인스턴스가 할당되어야 할 때 좀 더 효율적으로 사용하기 위해 사용하는 것이다.   
구체적으로 말하자면, 저장 지연 프로퍼티에 할당된 다른 클래스나 구조체의 인스턴스가 처음 호출되기 전까지 해당 저장 지연 프로퍼티를 생성하지 않는 것이다.
```
class SomeClass {
    var some = "some"
}
 
class OtherClass {
    lazy var newSome = SomeClass() // 저장 지연 프로퍼티
    var other = "other"
}
 
var result = OtherClass()
result.other = "another"
// 아직 newSome 생성안됨
 
result.newSome.some = "newSome"
// some의 첫 호출, newSome 생성
print(result.newSome.some)
```
이렇게 맨 앞에 `lazy` 키워드를 붙여서 사용하는데 저장 지연 프로퍼티는 반드시 **변수(var)** 로 선언해야 한다.
  
#### 저장 지연 프로퍼티는 어떤 때에 사용해야 할까?
 
- 프로퍼티가 특정 요소에 의존적이라서 적절한 값을 바로 알지 못하는 경우
- **복잡한 계산이 필요할 경우** : 어떤 데이터를 얻기 위해 초기화시 많은 시간이 소요될 예정이라면 해당 작업을 저장 지연 프로퍼티에 선언해, 실제 그 프로퍼티를 사용하기 전에는 복잡하고 오래 걸리는 연산을 하지 않게 할 수 있다.
 
### 연산 프로퍼티(Computed Property)
 
연산 프로퍼티는 값을 저장하지 않고 그때그때 연산하는 프로퍼티로, `get`과 옵셔널한 `set`을 제공해 값을 탐색하고 다른 프로퍼티 값을 설정해준다.(다른 프로퍼티에 할당할 값의 연산을 간접적으로 대신 해주는 셈)
```
class SomeClass {
    var result = 0
    var sum: Int {
        get {
            return result
        }
        set(newValue) {
            result += value
        }
    }
}
 
var test = SomeClass()
print(test.sum) // 0
 
test.sum = 5
print(test.result) // 5
```
`get`은 sum을 **호출**해 값을 **반환**할 때, `set`은 sum에 값을 **할당**하면 그 값을 newValue가 받아 **대신** 연산하고 다른 프로퍼티에게 결과를 **할당**할 때 호출된다.   
즉 `print(test.sum)`에서 **get**이 호출된 것이고, `test.sum = 5`에서 **set**이 호출돼 newValue에 5가 할당된 것이다.
 
set에 
 
set은 옵셔널하기 때문에 get의 경우만 정의해줘도 된다.
```
class SomeClass {
    var result = 0
    var sum: Int {
        get {
            return result
        }
    }
}
 
var test = SomeClass()
print(test.sum)
 
test.sum = 5 // error!
```
대신 set이 없을 땐 get-only 프로퍼티이기 때문에 값을 할당할 수 없다.
 
그리고 연산 프로퍼티는 값을 저장하지 않는 프로퍼티로, 값을 저장하지 않기 때문에 반드시 **변수(var)** 로 선언해줘야 한다.
