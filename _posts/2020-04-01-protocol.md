---
comments: true
title: [프로토콜(Protocol)]
key: 202004021
modify_date: 2020-04-03
picture_frame: shadow
tags:
  - [swift]
---

# 프로토콜

### 프로토콜이란?
먼저 프로토콜의 정의를 보자면 특정 작업이나 기능의 조각에 맞게 메서드, 속성 및 기타 요구 사항의 청사진이라고 하는데, 쉽게 말해 약속이나 규약이라고 생각하면 된다.   
   
프로토콜의 요구사항을 충족시키는 타입들은 프로토콜을 **준수**한다고 하는데, `as?`를 통해 프로토콜 준수 여부를 파악할 수 있다.   
프로토콜은 클래스, 구조체, 열거형에서 채택할 수 있으며, 채택된 곳에서 구현할 수 있다.   
   
반드시 기억해야 할 점은 프로토콜을 정의할 때는 메서드와 프로퍼티 **정의**만 하는 것이고, **구현**은 프로토콜이 채택된 곳에서 하는 것이다.
***

```
protocol SomeProtocol {
    // 프로토콜 정의
}
   
class SomeClass: SomeProtocol {
    // 프로토콜 구현
}
```
프로토콜 **정의**를 하고, 이렇게 상속받듯이 **채택**을 하면 프로토콜을 구현할 수 있다.
   
만약 채택하는 클래스가 서브클래스라면, 이렇게 부모 클래스를 먼저 명시해준다.
```
class SubClass: ParentClass, SomeProtocol {
    // code
}
```
프로토콜을 준수하는 순간 해당 기능들의 구현은 강제이며, 프로토콜을 채택한 타입이 원하는 기능을 강제로 구현한다.
   
# 프로토콜 요구사항
   
### Property Requirements
   
프로토콜은 자신을 채택하는 타입에게 인스턴스 프로퍼티 또는 타입 프로퍼티를 요구할 수 있다.   
프로퍼티의 이름과 타입은 명시하되 연산 프로퍼티인지, 저장 프로퍼티인지는 명시하지 않는다.   
   
그리고 프로퍼티 정의시 gettable, gettable & settable인지 명시해야 한다.
 
> 프로토콜 정의시 선언하는 프로퍼티는 항상 `var`로 선언한다.
 
```
protocol Info {
    var name: String { get }
    var grade: String { get set }
}
```
프로토콜을 채택하는 타입(클래스, 구조체 등..)은 반드시 해당 프로토콜에서 정의된 프로퍼티를 구현해줘야 한다.
```
class Student: Info {
    var name: String = "A"
    var age: Int = 0
     
    var grade: String {
        get {
            if age == 0 {
                return "정보없음"
            } else {
            return "\(age - 7)학년"
            }
        }
        set {
            age = 13
        }
    }
}
   
let student = Student()
print(student.grade) // "정보없음"
student.age = 13
print(student.grade) // "6학년"
```

### Method Requirements

프로토콜에서는 인스턴스 메소드와 타입 메소드를 정의할 수 있다.   
정의할 때 파라미터와 반환값은 명시할 수 있으나, {}를 통한 구현은 할 수 없다.
```
protocol SomeProtocol {
    func method(파라미터) -> 반환값
}
```
함수명 앞에 `mutating`을 붙이면 해당 프로토콜을 채택한 타입 내의 인스턴스값을 변경할 수 있다.

> 클래스를 위한 프로토콜에서는 mutating 키워드를 붙이지 않아도 인스턴스값을 자유롭게 변경할 수 있다.
 
```
protocol Togglable {
    mutating func toggle()
}
```
구조체나 열거형에서 채택된다면 mutating을 명시해 인스턴스를 변경해야 한다.
```
enum Switch: Togglable {
    case On, Off
    
    mutating func toggle() {
        switch self {
        case .On:
            self = .Off
            break
        case .Off:
            self = .On
            break
        }
    }
}
 
var result = Switch.On
result.toggle()
print(result) // off
```

### Initializer Requirements

이니셜라이저 또한 구현은 채택된 타입 내에서 해야 하는데, 앞에 `required` 키워드를 붙여줘야 한다.   
프로토콜에서 이니셜라이저 정의했다는 것은 **특정 이니셜라이저가 필요하다는 의미**이기 때문이다.
```
protocol SomeProtocol {
    init(parameter: Int)
}
 
class SomeClass: SomeProtocol {
    
    required init(parameter: Int) {
        // code
    }
}
```
동일한 프로토콜을 준수하는 서브클래스가 있을 경우, required 키워드를 사용하면 하위클래스도 이니셜라이저의 구현을 보장받을 수 있다.
 
특정 프로토콜의 이니셜라이저와 상속받은 SuperClass의 이니셜라이저를 구현할 때는 `required ovveride` 또는 `override required` 키워드를 붙여준다.
```
protocol SomeProtocol {
    init(_ parameter: String)
}
 
class SuperClass {
    
    init(_ parameter: String) {
        // 구현
    }
}
 
class SubClass: SuperClass, SomeProtocol {
    
    required override init(_ paramter: String) {
        // 구현
    }
}
```
구조체나 final 클래스에서는 `required` 키워드를 붙이지 않아도 된다.   
final 클래스는 더이상 상속할 수 없는 클래스이기 때문이다.
```
final class FinalClass: SomeProtocol {
    init(_ paramter: String) {
        // 구현
    }
}
```

# 프로토콜의 상속

프로토콜도 다른 프로토콜을 상속받아 더 많은 요구사항을 추가할 수 있다.
```
protocol SomeProtocol {
    func someMethod()
}
 
protocol OtherProtocol {
    func otherMethod()
}
 
protocol AnotherProtocol: SomeProtocol, OtherProtocol {
    func anotherMethod()
}
 
class SomeClass: AnotherProtocol {
    func anotherMethod() {
        // 구현
    }
    
    func someMethod() {
        // 구현
    }
    
    func otherMethod() {
        // 구현
    }
}
```
SomeClass는 SomeProtocol과 OtherProtocol을 상속받는 AnotherProtocol을 상속받음으로 프로토콜 3개를 모두 상속받는 것과 같다.

# Extension

타입에 기능을 추가하기 위한 것으로, 기능을 수평적으로 확장할 수 있다.   
때문에 주로 새로운 프로토콜을 채택할 때 가독성을 높이기 위해 사용된다.
```
protocol SomeProtocol {
    func someMethod()
}
 
class SomeClass {
    // code
}
 
extension SomeClass: SomeProtocol {
    func someMethod() {
        // 구현
    }
}
```
프로퍼티는 **연산프로퍼티**만 사용할 수 있다.   

### 조건부 Extension
extension에 `where` 키워드를 사용하여 조건을 줄 수 있다.   
`where` 뒤에 명시된 조건에 해당될 때만 extension이 적용된다.
```
protocol SomeProtocol {
    func someMethod()
}
 
protocol OtherProtocol {
    func otherMethod()
}
 
protocol AnotherProtocol {
    func anotherMethod()
}
// OtherProtocol과 AnotherProtocol도 채택한 타입에만 이 extesion이 적용된다.
extension SomeProtocol where Self: OtherProtocol, Self: AnotherProtocol {
    func anyMethod() {
        // code
    }
}
```

# Delegation

- extension 기능을 사용해 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있다.(수평확장)
> extenstion 기능은 타입에 새로운 기능은 추가할 수 있지만, 기존에 정의된 기능을 재정의할 수는 없다.
  
```
extension 확장할 타입 이름: 프로토콜1, 프로토콜2, 프로토콜3 {
  //프로토콜 요구사항 구현
}
```

# 타입으로서 프로토콜

- 사실 프로토콜은 일종의 타입이고, 매개변수, 리턴타입, 상수, 변수, 프로퍼티타입, array나 dictionary 타입으로 사용 가능하다.
- 프로토콜에 메소드가 선언되어 있어도 구현해주지 않아도 된다.



### Q. 프로토콜이란 무엇인지 설명하시오

**A.** 프로토콜은 ~
