---
comments: true
title: [프로토콜(Protocol)]
key: 202004021
modify_date: 2020-04-03
picture_frame: shadow
tags:
  - [swift]
  - [interview]
---

# 프로토콜

### 프로토콜이란?
먼저 프로토콜의 정의를 보자면 특정 작업이나 기능의 조각에 맞게 메서드, 속성 및 기타 요구 사항의 청사진이라고 하는데, 쉽게 말해 약속이나 규약이라고 생각하면 된다.   
   
프로토콜의 요구사항을 충족시키는 타입들은 프로토콜을 **준수**한다고 하는데, `as?`를 통해 프로토콜 준수 여부를 파악할 수 있다.   
프로토콜은 클래스, 구조체, 열거형에서 채택할 수 있으며, 채택된 곳에서 구현할 수 있다.   
   
반드시 기억해야 할 점은 프로토콜을 정의할 때는 메서드와 프로퍼티 **정의**만 하는 것이고, **구현**은 프로토콜이 채택된 곳에서 하는 것이다.
***

```
protocol SomeProtocol {
    // 프로토콜 정의
}
   
class SomeClass: SomeProtocol {
    // 프로토콜 구현
}
```
프로토콜 **정의**를 하고, 이렇게 상속받듯이 **채택**을 하면 프로토콜을 구현할 수 있다.
   
만약 채택하는 클래스가 서브클래스라면, 이렇게 부모 클래스를 먼저 명시해준다.
```
class SubClass: ParentClass, SomeProtocol {
    // code
}
```
프로토콜을 준수하는 순간 해당 기능들의 구현은 강제이며, 프로토콜을 채택한 타입이 원하는 기능을 강제로 구현한다.
   
# 프로토콜 요구사항
   
### Property Requirements
   
프로토콜은 자신을 채택하는 타입에게 인스턴스 프로퍼티 또는 타입 프로퍼티를 요구할 수 있다.   
프로퍼티의 이름과 타입은 명시하되 연산 프로퍼티인지, 저장 프로퍼티인지는 명시하지 않는다.   
   
한가지 더 요구되는 것이,   
프로퍼티 정의시 gettable, gettable & settable인지 명시해야 한다.
 
> 프로토콜 정의시 선언하는 프로퍼티는 항상 `var`로 선언한다.
 
```
protocol Info {
    var name: String { get }
    var grade: String { get set }
}
```
프로토콜을 채택하는 타입(클래스, 구조체 등..)은 반드시 해당 프로토콜에서 정의된 프로퍼티를 구현해줘야 한다.
```
class Student: Info {
    var name: String = "A"
    var age: Int = 0
     
    var grade: String {
        get {
            if age == 0 {
                return "정보없음"
            } else {
            return "\(age - 7)학년"
            }
        }
        set {
            age = 13
        }
    }
}
   
let student = Student()
print(student.grade) // "정보없음"
student.age = 13
print(student.grade) // "6학년"
```

### Method Requirements

프로토콜에서는 인스턴스 메소드와 타입 메소드를 정의할 수 있다.   
정의할 때 파라미터와 반환값은 명시할 수 있으나, {}를 통한 구현은 할 수 없다.
```
protocol SomeProtocol {
    func method(파라미터) -> 반환값
}
```
함수명 앞에 `mutating`을 붙이면 해당 프로토콜을 채택한 타입 내의 인스턴스값을 변경할 수 있다.

> 클래스를 위한 프로토콜에서는 mutating 키워드를 붙이지 않아도 인스턴스값을 자유롭게 변경할 수 있다.
 
```
protocol Togglable {
    mutating func toggle()
}
```
구조체나 열거형에서 채택된다면 mutating을 명시해 인스턴스를 변경해야 한다.
```
enum Switch: Togglable {
    case On, Off
    
    mutating func toggle() {
        switch self {
        case .On:
            self = .Off
            break
        case .Off:
            self = .On
            break
        }
    }
}
 
var result = Switch.On
result.toggle()
print(result) // off
```

### Initializer Requirements

- 이니셜라이저 역시 선언만 하고 구현코드는 채택한 곳에서 명시한다.
- 동일한 프로토콜을 준수하는 서브클래스가 있을 경우, required 키워드를 사용하면 하위클래스도 이니셜라이저의 구현을 보장받을 수 있다.
> 구조체와 final 클래스에서는 required 키워드를 사용하지 않아도 된다.   

# 타입으로서 프로토콜

- 사실 프로토콜은 일종의 타입이고, 매개변수, 리턴타입, 상수, 변수, 프로퍼티타입, array나 dictionary 타입으로 사용 가능하다.
- 프로토콜에 메소드가 선언되어 있어도 구현해주지 않아도 된다.

# Delegation

- extension 기능을 사용해 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있다.(수평확장)
> extenstion 기능은 타입에 새로운 기능은 추가할 수 있지만, 기존에 정의된 기능을 재정의할 수는 없다.
  
```
extension 확장할 타입 이름: 프로토콜1, 프로토콜2, 프로토콜3 {
  //프로토콜 요구사항 구현
}
```

### 프로토콜의 상속
- 프로토콜은 하나 이상의 다른 프로토콜을 상속할 수 있으며, 상속된 요구사항에 다른 요구사항을 추가할 수 있다.



### Q. 프로토콜이란 무엇인지 설명하시오

**A.** 프로토콜은 ~
