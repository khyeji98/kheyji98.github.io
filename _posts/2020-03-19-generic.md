---
comments: true
title: [Swift ) 제네릭(Generic)]
key: 202003191
modify_date: 2020-10-31
picture_frame: shadow
tags:
  - [swift]
---
 
# Generic
 
### Generic이란?
 
제네릭은 스위프트의 가장 강력한 도구 중 하나로, 제네릭을 사용하면 유연하고 재사용성이 높은 코드를 작성할 수 있다고 한다.   
실제로 우리는 지금까지 제네릭을 사용해왔다. 한가지 예로는 Array와 Dictionary가 제네릭 콜렉션이다.   
```
func printIntValue(_ a: Int) {
    print("IntValue: \(a)")
}
```
Int값을 파라미터로 받아 프린트하는 함수가 있다.
```
func printStringValue(_ a: String) {
    print("String: \(a)")
}
```
그리고 String값을 파라미터로 받아 프린트하는 함수가 있다.
 
두 함수는 파라미터의 타입만 다를뿐, 같은 코드를 실행하는 것이다.   
이렇게 되면 같은 코드인데 비효율적으로 두개의 파라미터의 타입만 다른 두 함수를 모두 작성하고 각각 사용해야 한다.   
 
이럴 때 **제네릭**을 사용할 수 있는데,
```
func printValue<T>(_ a: T) {
    print("Value: \(a)")
}
```
제네릭은 이렇게 사용한다.   
함수명 옆에 `<T>`가 추가되었고 파라미터인 a가 T타입이라고 되어있는데 이때 T는 **타입 파라미터**라고 부른다.   
이 타입 파라미터는 해당 함수가 호출될 때 파라미터를 입력하면서 타입이 결정되는 것이다.   
 
*말그대로 T는 placeholder로, 실제 타입 이름이 아니다.*
 
고로, 이 타입 파라미터는 함수가 호출될 때마다 실제 타입으로 치환되는 placeholder라는 것이다.   
타입 이름은 <>와 파라미터 타입에 동일하게 명시하기만 하면 상관없는데 보통 T, V, U 중에 사용하는 편이다.
```
func printValue<T>(_ a: T, _ b: T) {
    print("Values: \(a), \(b)")
}
```
만약
타입 이름은 <>와 파라미터 타입에 동일하게 명시하기만 하면 상관없는데 보통 T, V, U 중에 사용하는 편이다.

### 우리가 Generic을 사용해야 하는 이유
 
- 제네릭을 이용해 코드를 구현하면 **어떤 타입에도 유연하게 대응**할 수 있다.
- 제네릭으로 구현한 기능과 타입은 **재사용**하기도 쉬워, **코드의 중복을 줄일 수 있다.**
 
#### Reference)
 
