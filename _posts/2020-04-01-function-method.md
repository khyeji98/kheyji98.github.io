---
comments: true
title: [Swift ) 함수와 메소드(Function VS Method)]
key: 202004011
modify_date: 2020-10-24
picture_frame: shadow
tags:
  - [swift]
---
 
# Funtion VS Method
 
함수와 메소드, 대충 의미는 알겠지만 차이를 모르고 커뮤니케이션할 때 사용해왔다.   
 
간단하게 말하자면 전역이던, 지역이던 독립적인 기능을 수행하는 **코드조각**을 **함수(function)**,   
클래스, 구조체, 열거형 타입 내에서 정의된 **함수**를 **메소드(Method)** 라고 한다.   
결국 메소드도 함수의 일종이라는 것이고 우리가 흔히 볼 수 있는 ViewController 내에서 정의되는 함수는 **메소드**라고 할 수 있다.   
 
```
func someFunction() {
    // code
}
 
class SomeClass {
 
    func someMethod() {
        // code
    }
    
}
```
아무래도 프로젝트 중 커뮤니케이션을 할 때는 대부분 메소드를 다루기 때문에 함수와 메소드의 차이를 몰랐을 것이다.   
 
그렇다면 알고리즘 코드리뷰할 때는 **함수**라고 해야할까, **메소드**라고 해야할까?   
Command Line Tool에서는 클래스를 만들 일이 드물기 적기 때문에 함수라고 많이들 얘기했던 것이다.   
고로 상황에 따라 함수, 메소드를 사용하는 것이 아닌 그 차이를 명확히 알고 써야할 것!!   
 
그렇다면 이제 함수와 메소드의 차이도 명확히 알았으니 둘에 대해 더 자세히 알아보자.
 
# Function
 
### 기본 함수

함수는 특정 기능을 **반복적**으로 할 때 사용하기 위해 만들어진 코드블럭이다.   
먼저 함수 선언의 기본 형태부터 이해해야 다양한 형태의 함수를 이해할 수 있다.
```
func someFunction(파라미터명: 타입) -> 반환타입 {
  // code
}
```
실제 함수를 선언(정의)한 것과 호출한 것이다.
```
// 선언(정의)
func setData(_ data: String) {
    print("Data: \(data)")
}
// 호출
setData(함수) // "Data: 함수"
```
파라미터를 보면 `_ data: String`으로 되어 있는데 여기서 `_`는 함수를 호출할 때 넘기는 파라미터 앞에 라벨, 즉 **파라미터명을 생략**하기 위해 사용되는 것으로 정식명칭은 underscore라고 한다.
 
만약 파라미터명을 생략하지 않는다면
```
func setData(data: String) {
    print("Data: \(data)")
}
  
setData(data: 함수) // "Data: 함수"
```
이렇게 호출될 것이다.
 
### 튜플(Tuple)
 
함수는 기본적으로 반환값이 하나이다.   
그러나 **튜플**을 사용하면 멀티 반환값을 반환할 수 있는데, 튜플이란 배열과 같지만 변경이 불가능한 배열이라고 볼 수 있다.   
```
func someFunction(a: Int, b: Int) -> (Int, Int) {
    return (a, b)
}
```
여기서 `(Int, Int)`와 `(a, b)`가 튜플을 사용한 멀티 반환값이다.   
 
이 외에도 클로저를 사용한 함수 선언 유형이 있다.

### 클로저(Closure)
 
클로저란 코드 내에서 전달되며 사용되는 코드블럭으로, `{}`으로 구분된다.   
함수 역시 클로저의 한 형태이기 때문에 **이름있는 클로저**라고 보면 된다.   
 
클로저는 할당받기, 파라미터 전달, 값 반환 등이 모두 가능한 1급객체이며, 정의되어 있는 상수나 변수들을 참조하거나 저장할 수 있다.   
클로저에는 여러가지 형태가 있는데 우선 기본 형태부터 이해하자.
```
{ (파라미터) -> 반환타입 in
    // code
}
```
클로저도 함수와 같다고 생각하면 된다.
 
알고리즘을 풀 때 클로저는 아주 유용하게 사용된다.
```
let num = [15, 2, 34, 4]
 
let sortedNum = num.sorted(by: { (a: Int, b: Int) -> Bool in
    return a < b
})
 
print(sortedNum) // [2, 4, 15, 34]
```
이렇게 `()`안에 있는 클로저를 인라인 클로저(Inline Closure)라고 한다.   
 
하지만 굳이 인라인 클로저로 작성하지 않아도 결과는 같다.
```
let num = [15, 2, 34, 4]
 
let sortedNum = num.sorted { (a: Int, b: Int) -> Bool in
    return a < b
}
 
print(sortedNum)
```
클로저는 축약을 통해 다양한 형태로 사용할 수 있다.   
 
#### 타입 생략
 
**타입 생략**은 sorted라는 메소드를 정의할 때 이미 파라미터 타입을 정했기 때문에 클로저를 사용할 때는 파라미터명만 명시하고 파라미터 타입은 생략할 수 있다.
```
let sortedNum = num.sorted { (a, b) -> Bool in
    return a < b
}
```
 
#### 반환 타입 생략
 
**반환 타입 생략** 역시 메소드 정의시 반환타입이 이미 정해졌기 때문에 생략할 수 있다.
```
let sortedNum = num.sorted { (a, b) in
    return a < b
}
```
 
#### 파라미터명 생략
 
어차피 클로저 내에서 정해진 파라미터는 클로저 내에서만 유효한 변수이기 때문에 간단한 코드만 구현할 것이라면 파라미터명을 생략해도 된다.   
```
let sortedNum = num.sorted { $0 < $1 }
```
num 배열을 재배열할 때 원소 두 개만 본다고 생각하면, 앞에 있는 원소가 **$0**이고 뒤에 있는 원소가 **$1**이므로   
`2 < 4`, `4 < 15`, `15 < 34` 이렇게 되어 Int값을 오름차순으로 정렬할 수 있게 된다.   
당연한 것같아 보여도 처음 알고리즘을 공부할 때 바로 이해가 안된건 안비밀 ;)   
 
#### 연산자 메소드
 
**연산자 메소드**는 말 그대로 연산자만 사용할 수 있는 코드를 구현할 것이라면, 연산자만 명시할 수 있다는 것이다.   
대신 연산자 메소드를 사용할 땐 (모든 메소드가 그런지는 모르겠지만) `{}`만으로 구분할 수 없다.
```
let sortedNum = num.sorted(by: <)
```

#### 후행 클로저
 
1)클로저를 어떤 메소드의 파라미터로 사용하고 2)클로저의 구현 코드가 길 경우, **후행 클로저**를 통해 함수의 뒤에 코드를 구현할 수 있다.
```
let sortedNum = num.sorted() { (a, b) in
    return a < b
}
```
이렇게 함수를 `()`로 닫고, 뒤에 `{}` 코드블럭을 통해 구현하는 것이다.
 
    
> 클로저는 많이 사용되고 중요한 파트이기 때문에 공부한 기록을 따로 포스팅할 예정이다.
 
# Method

 
